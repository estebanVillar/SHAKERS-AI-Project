# Recommendation System Part 1: The User Profile and Interest Vector

## 1. The Foundation of Personalization

To provide personalized recommendations, the system must first understand the user. This is achieved by building a user profile that dynamically captures a user's interests during their chat session. This profile serves as the "brain" for the recommendation engine, enabling it to move beyond generic suggestions to offer content tailored specifically to the user's line of inquiry.

All profile data is persisted in the `app/data/evaluation/user_profiles.json` file. To ensure data integrity, especially in a multi-threaded environment, all write operations to this file are protected by a `threading.Lock` (`file_lock` in `main.py`).

---

## 2. Structure of the User Profile

Each user is identified by a unique `user_id` generated by the Streamlit frontend. Their corresponding profile in the JSON file is an object with three key components:

*   **`query_history`**: A chronological log of every raw query the user has submitted, complete with timestamps. This serves as a raw audit trail of the user's journey.

*   **`inferred_interests`**: A list of unique document `topics` that the user has already been exposed to. This list is populated from the `sources` that are retrieved by the RAG chain in response to a user's query.

    *   **Why this is crucial:** This list is the system's "memory" of what the user has already seen. The recommendation logic uses this list to prioritize suggesting **new, unconsulted documents**, directly fulfilling the requirement to help users explore a wider range of topics.

*   **`profile_vector`**: This is the most critical component for personalization. It is a single vector (a list of floating-point numbers) that numerically represents the user's aggregated interests.

---

## 3. The Evolving Profile Vector

The `profile_vector` is not static; it evolves with every query the user makes, becoming a more accurate representation of their interests over time.

#### **What it Represents:**
The vector represents a point in a high-dimensional "concept space". Topics with similar meanings will have vectors that are closer together in this space. The user's `profile_vector` is their "center of gravity" in this space.

#### **How it is Calculated and Updated:**
This logic resides within the `handle_query` function in `main.py` and is executed after every valid user query.

1.  **Embed the Current Query:** The user's latest query is converted into a vector using the same `models/embedding-001` model that was used for the documents.

2.  **Average with Past Interests:**
    *   If the user already has a `profile_vector` (i.e., this is not their first query), the system takes the existing vector and averages it with the new query's vector using `numpy.mean`. This subtly shifts the user's interest vector in the direction of their latest query.
    *   If this is the user's first query, their new query vector becomes their initial `profile_vector`.

3.  **Persist the Update:** The newly calculated `profile_vector` is saved back into the `user_profiles.json` file, ready for the next recommendation request.

#### **Why this Approach Was Chosen:**
This "moving average" of embeddings is a computationally efficient yet highly effective method for modeling user interest.

*   **Efficiency:** It avoids the need for complex models or retraining. The profile update is a simple, sub-second mathematical operation.
*   **Effectiveness:** It naturally weights recent queries slightly more, allowing the profile to adapt to shifts in the user's focus during a single conversation, fulfilling the requirement to base recommendations on the "current context and user profile."